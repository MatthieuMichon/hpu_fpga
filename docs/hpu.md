<h1 style="text-align: center;">HPU</h1>

# What is an HPU?

HPU stands for Homomorphic Processing Unit. This is a processor on homomorphically encrypted data. It receives encrypted operands and a stream of instructions and executes these instructions.<br>
HPU is a hardware accelerator dedicated to TFHE processing running (today) on FPGA which contains all the logic needed to execute a large number of boolean & integer operations on encrypted operands of various sizes.<br>
Zama's HPU is integrated with **TFHE-rs** and receives its encrypted operands and instructions from this library when the tfhe-hpu-backend is enabled.

## Components
The main components of an HPU are:

 - a large memory containing the cryptographic keys and the encrypted operands or ciphertexts (it is nice when this memory is an HBM).
 - a register file containing a set of ciphertexts.
 - a load/store unit in charge of reading/writing ciphertexts from/into the register file and into/from the large memory.
 - an ALU (Arithmetic Logic Unit) which executes arithmetic operations on the ciphertexts.
 - a PBS (Programmable Bootstrapping) processing element which reduces the noise contained in a ciphertext to allow a process to continue. And in the case of TFHE, it also applies a LUT function to the ciphertext (programmable property).
 - a key-switching processing element associated with the PBS processing element to maintain ciphertext encrypted with the same key through the whole process on the HPU.
 - a controller receiving the input instructions, generating the micro-code corresponding to these instructions and scheduling execution of this micro-code.

<p align="center">
<!-- HPU schematic -->
<picture>
  <source srcset="./img/hpu_schematic.png">
  <img width=1000 alt="Zama HPU on FPGA">
</picture>
</p>

#### Large Memory
On V80, this memory is implemented using the x2 available HBM2e. It is used to store the keys (KSK and BSK), the look-up-tables (LUT in a GLWE form) necessary for the PBS and the ciphertexts (input, results, intermediate computations). A part of the memory dedicated to ciphertexts is used for inputs and outputs of the HPU which are moved to and from the host memory through PCIe DMA. Another part is used for a heap of ciphertexts which is used to temporarily store some ciphertexts that do not fit in the register file during the operations.

#### Register file
This is a, typically 64-entry, array of ciphertexts which is used to store locally ciphertexts that are intended for the processing elements (ALU, PBS, load-store unit).

#### PBS & KS processing element
In the current HPU version, PBS and KS are gathered inside the same processing element.<br>
This is the most complex PE of the HPU. It uses most of the logic inside the FPGA matrix.<br>
It instantiates a cache to load slices of the key-switching key (KSK) and bootstrapping key (BSK). It executes key-switch and blind-rotation in parallel on a set of ciphertexts called a batch. During an iteration, the whole batch uses the same slice of key. The batch is sized so that the next key slice is entirely loaded while processing the current one. On the FPGA and with current TFHE parameter sets, the batches are typically composed of 8 or 12 ciphertexts.<br>
TFHE PBS is implemented in the HPU using a blind-rotation as described in this [blog-post](https://www.zama.ai/post/tfhe-deep-dive-part-1) and the external product between the LUT accumulator and the BSK is implemented using a NTT.

## How does it work?

### Initialization

Before starting its process, an HPU instance needs to be initialized by TFHE-rs.\
This initialization can be described as follow:
1. TFHE-rs reads the TFHE parameter set (number of bits of keys, size of polynomials...) in HPU registers. They correspond to the TFHE parameter set for which the current HPU instance has been compiled.
2. Based on this parameter set, TFHE-rs prepares the BSK & KSK needed by the HPU and writes these keys into the HPU large memory.
3. TFHE-rs writes the micro-code of each operation into the large memory. This part is accessible by the HPU controller.

### IOp operations

The input instructions of Zama's HPU are named [IOp](./iop.md) (Integer Operations). These instructions are generated by TFHE-rs when using tfhe-hpu-backend and sent through the PCIe link to the HPU controller. The controller reads these IOps and generates the HPU micro-code corresponding to these IOps. Each instruction of this micro-code is what we call a [DOp](./dop.md) (Digit Operations).
When the micro-code of an IOp has been fully executed, the controller generates an IOp acknowledge which is sent to the tfhe-hpu-backend via the PCIe link.

### DOp operations

Each DOp is an instruction for a given processing element. Load and Store are for the Load/Store unit, PBS instructions are for the PBS processing element, linear operations are for the ALU. You can find a detailed description of these instructions [here](./dop.md). Each of these DOp are scheduled by the controller based on their dependencies and the availability of the processing element.

### Ciphertexts

The encrypted operands of the HPU operations are TFHE encrypted types like [FheUint64](https://docs.zama.ai/tfhe-rs/fhe-computation/types/integer) or [FheAsciiString](https://docs.zama.ai/tfhe-rs/fhe-computation/types/strings) which are decomposed in arrays of smaller ciphertexts, each encrypting a part of the operands.<br>
These smaller ciphertexts (or radix ciphertexts) are the default words of the HPU, like 64b words would be for a classic ARM or x86 processor. Each slot of the register file (regfile) contains one of these radix ciphertexts. A DOp describes an operation on these radix ciphertexts stored in the regfile.
