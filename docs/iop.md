# Integer Operation (IOp)

Current version is **HIS v2.0** (HPU Instruction Syntax).

The Homomorphic processing unit (HPU) processes any operation on integers, using their radix representation. For this, the user only needs to provide a program to the HPU.

There are 2 levels of HPU programming.

* The high level one handles the *integers*.
* The second one is low level. This code is the equivalent of assembly code for traditional CPU, but processing on elementary ciphertexts encoding *digits*.

This document describes the high level code syntax. The targeted elements are integers. The operations are named **Integer Operation** (IOp).

## Integer / Digit
An integer is any type that can be represented with bits. Let's name *n* the number of bits.

The integer is decomposed into a base *B*, which is a power of 2 : *B* = 2^*b*. This is called the radix representation. Each element of this decomposition is called *digit*.

Therefore an integer of *n* bits is composed into (*n*+1)//*b* digits. Each digit is actually an elementary ciphertext (also called *blocks* in tfhe-rs documentation), each encoding *b* bits.

> [!NOTE]
> if *n* is not a multiple of *b*, the HPU actually does its computation on a bigger integer which number of bits is a multiple of *b*.

At this day the base is *B* = 4, so a digit is a 2-bit value (*b*=2).

The HPU is able to handle any size of integer, as long as its representation and the intermediate results can be stored in the local memory of the HPU.

## Syntax
The IOp code defines the integer **operation signature**. This makes it an identifier used as a link to a **Digit Operation** (DOp) code. Indeed, the effective computation is done on the digit ciphertext level.

An IOp code is defined by **positional** sections:

* A name
* A list of features
* A list of destination integers
* A list of source integers
* A list of immediates (optional)


General IOp syntax:
```
NAME <Features> <DST list> <SRC list> [<Imm list>]
```

### Key words
| Symbol | Definition |
|--------|------------|
| < > | Angle brackets are used to delimit each section, except the name. |
|I*n*| Defines an integer of *n* bits.<br>Any n value, **multiple of b**, is supported.|
|@| Precedes an offset in memory, defined in ciphertext unit.<br>Supports hexa value.|
|dyn| Indicates that the DOp is generated/modified at runtime.|

### Name
An 8-bit value is used as IOp identifier.

The following encoding is used :

| Range      | Categories                | Comment |
| ---------- | ------------------------- | ----------- |
| 0x00 .. 0x7f| User custom operations    | The user can create new IOps using these identifiers.<br> The user will also provide the associated DOp code.|
| 0x80 .. 0xff| Generated operations   | The associated DOp code is generated by the tfhe-rs hpu backend module *fw*.<br>Some values are already used for pre-defined basic operations.<br>The others can be used to define new IOPs. In this case the associated DOp code has to be defined in the backend code.|


[Predefined IOps](#predefined-iop) have reserved values and alias names.

User custom IOp names have the following syntax:

```
IOP[val]
```

where *val* is a free 8-bit value, respecting the encoding described above.


### Feature
The HPU is able to process any size of integer. It is even able to mix different sizes for the sources and the destinations.
However from a memory storage point of view, the HPU needs to know the unit that is used to align the integer ciphertexts. This is given in the feature section, with the I*n* keyword.

The first element defines the destination integers alignment, the second the sources.

In the following example:

* The destinations are aligned on 8-bit integer ciphertexts
* The sources are aligned on 16-bit integer ciphertexts.
```
<I8 I16>
```

> [!NOTE]
> The alignment must take into account the biggest integer that is processed by this operation. I.e. the alignment should be equal or bigger to the biggest processed integer of this category source or destination.

#### Future feature: dyn
HIS v2.0 syntax defines the possibility to have *dynamic* run-time generated code. If the IOp is qualified as dynamic, it means that the HPU micro-processor could, if instructed, use current execution environment information to modify the DOp code.

Example:
```
<dyn I8 I16>
```
> [!NOTE]
> The feature is not fully supported yet.

### Destination / Source
The destination and source sections follow the same syntax.

Within the destination section, one or several destination integers are defined. The same is valid for the source section.

An integer is characterized by:

* its size in bit-unit
* its offset in memory (offset in elementary ciphertext unit). This offset should be aligned as described in the feature section.

Example:

* If the elementary ciphertexts encode 2 bits
* If the destination alignment is I8 (so 4 blocks per destination)
* 2 destinations
    * the first one with 2 bits at offset 4
    * the second with 8 bits at offset 16
```
<I2@0x4 I8@0x10>
```

> [!NOTE]
> In general, within a section (source or destination), the offsets do not overlap. If they do, it is on purpose. This means that part of the integer has the same blocks as the other one.

> [!NOTE]
> The offsets could overlap between integers of different sections. Indeed, the lifetime of source and destination is not the same. Therefore, the destination could overwrite the location of a source. This is the case for "in-place" operation.

User could also leverage the *Vector* notation to express a set of contiguous elements in memory.
A vector is characterized by:

* its size in bit-unit
* its offset in memory (offset in elementary ciphertext unit). This offset should be aligned as described in the feature section.
* its number of elements

Example:

* if the alignment is I16 (so 8 blocks per operands)
* if the vector ciphertexts encode 8 bits operands
* If the vector is composed of 4 contiguous operands
```
<I8[4]@0x0>
```
> [!NOTE]
> This vector describes a list of 4 ciphertexts and is equivalent to `<I8@0x0 I8@0x8 I8@0x10 I8@0x18>`

> [!NOTE]
> Vector alignment is based on global alignment expressed in *Feature* section (i.e. I16 in the example), not on operands size (i.e. I8 in the example).


### Immediate
The last section contains immediates. This section is optional.
As the sources and destinations they can be any number and any size.

In the following example, 2 immediates: 0, and 0xAACOFFEE.
```
<0x0 0xAACOFFEE>
```

> [!NOTE]
> Immediate size is computed based on their non-zero digits.

## Predefined IOp
A set of predefined IOps are available. They correspond to basic operations.

To ease their usage, aliases are used for their naming.

* D*n*: is used to define a destination integer of size n.
* S*n*: is used to define a destination integer of size n.

> [!NOTE]
> In the feature section, the integer sizes set here are the minimal values that should be used.

| Alias | IOp | Syntax | Description |
|-----|-------|--------|-------------|
|ADDS|0xA0|ADDS <D*n* S*n*\> <D*n*\> <S*n*\> <Imm\>|Add a constant to the n-bit source.<br>The result is reduced modulo 2^n.<br>Only n bits of the immediate are taken into account.|
|SUBS|0xA1|SUBS <D*n* S*n*\> <D*n*\> <S*n*\> <Imm\>|Subtract a constant to the n-bit source.<br>The result is reduced modulo 2^n.<br>Only n bits of the immediate are taken into account.|
|SSUB|0xA2|SSUB <D*n* S*n*\> <D*n*\> <S*n*\> <Imm\>|Subtract the n-bit source to a constant.<br>The result is reduced modulo 2^n.<br>Only n bits of the immediate are taken into account.|
|MULS|0xA3|MULS <D*n* S*n*\> <D*n*\> <S*n*\> <Imm\>|Multiply the n-bit source with a constant.The result is reduced modulo 2^n.|
|ADD|0xE0|ADD <D*n* S*n*\> <D*n*\> <S*n* S*n*\>|Add the 2 n-bit sources.<br>The result is reduced modulo 2^n.|
|SUB|0xE2|SUB <D*n* S*n*\> <D*n*\> <S*n* S*n*\>|Subtract the 2 n-bit sources.<br>The result is reduced modulo 2^n.|
|MUL|0xE4|MUL <D*n* S*n*\> <D*n*\> <S*n*\>|Multiply the 2 n-bit sources.<br>The result is reduced modulo 2^n.|
|BW_AND|0xD0|BW_AND <D*n* S*n*\> <D*n*\> <S*n* S*n*\>|Bit-wise AND on the 2 n-bit sources.|
|BW_OR|0xD1|BW_OR <D*n* S*n*\> <D*n*\> <S*n* S*n*\>|Bit-wise OR on the 2 n-bit sources.|
|BW_XOR|0xD2|BW_XOR <D*n* S*n*\> <D*n*\> <S*n* S*n*\>|Bit-wise XOR on the 2 n-bit sources.|
|CMP_GT|0xC0|CMP_GT <D*b* S*n*\> <D*b*\> <S*n* S*n*\>|Compare the 2 n-bit sources.<br>Output a boolean encoded in b-bits, with value (1) if source1 is greater than source2, and (0) elsewise|
|CMP_GTE|0xC1|CMP_GTE <D*b* S*n*\> <D*b*\> <S*n* S*n*\>|Compare the 2 n-bit sources.<br>Output a boolean encoded in b-bits, with value (1) if source1 is greater or equal than source2, and (0) elsewise|
|CMP_LT|0xC2|CMP_LT <D*b* S*n*\> <D*b*\> <S*n* S*n*\>|Compare the 2 n-bit sources.<br>Output a boolean encoded in b-bits, with value (1) if source1 is less than source2, and (0) elsewise|
|CMP_LTE|0xC3|CMP_LTE <D*b* S*n*\> <D*b*\> <S*n* S*n*\>|Compare the 2 n-bit sources.<br>Output a boolean encoded in b-bits, with value (1) if source1 is less or equal than source2, and (0) elsewise|
|CMP_EQ|0xC4|CMP_EQ <D*b* S*n*\> <D*b*\> <S*n* S*n*\>|Compare the 2 n-bit sources.<br>Output a boolean encoded in b-bits, with value (1) if source1 is equal to source2, and (0) elsewise|
|CMP_NEQ|0xC5|CMP_NEQ <D*b* S*n*\> <D*b*\> <S*n* S*n*\>|Compare the 2 n-bit sources.<br>Output a boolean encoded in b-bits, with value (1) if source1 is not equal to source2, and (0) elsewise|
|IF_THEN_ZERO|0xCA|IF_THEN_ZERO <D*n* S*n*\> <D*n*\> <S*b* S*n*\>|According to boolean source1 value, if (1) source2 is selected, else the value 0 is selected.|
|IF_THEN_ELSE|0xCB|IF_THEN_ELSE <D*n* S*n*\> <D*n*\> <S*b* S*n* S*n*\>|According to boolean source1 value, if (1) source2 is selected, else the source3 is selected.|
|ERC_20|0x80|ERC_20 <D*n* S*n*\> <D*n*\> <S*n* S*n*\> <Imm\>|ERC20 transaction.|
|Reserved|0xFE||Reserved|
|MEMCPY|0xFF|MEMCPY <D*n* S*n*\> <D*n*\> <S*n*\>|Copy ciphertext from one slot to another of the HPU memory|


## Examples
### Predefined
Here is an example of IOp code, using predefined IOps. The computation is the following:
```
A and B two 16-bit integers
if (A > B) D = A-B
else       D = B-A
return D
```
* A is stored in @0x8
* B is stored in @0x10
* Result is stored in 0x00

```
# Use @0x00 to store intermediate result: the select
CMP_GT <I16 I16> <I2@0x00> <I16@0x8 I16@0x10>
# Need @0x18 and @0x20 for intermediate results
SUB <I16 I16> <I2@0x18> <I16@0x8 I16@0x10>
SUB <I16 I16> <I2@0x20> <I16@0x10 I16@0x8>
IF_THEN_ELSE <I16 I16> <I16@0x00> <I2@0x00 I16@0x18 I16@0x20>
```

### Custom

32-bit Addition with overflow. This operation needs:

* 2 sources
* 2 destinations: the first contains the addition result, the second is a boolean containing the overflow information.
```
IOP[0x00] <I32 I32> <I32@0x10 I2@0x0> <I32@0x20 I32@0x30>
```

Multiplication between a 4-bit integer and a 32-bit integer. The result is reduced modulo 2^34, with an overflow boolean.

* 2 sources : 4-bit and 32-bit
* 2 destinations: the first contains the addition result, the second is a boolean containing the overflow information.
* The result partially overwrites source1 location.
```
IOP[0x01] <I34 I32> <I34@0x11 I2@0x0> <I32@0x20 I32@0x30>
```

Select among a list of 4 elements.

* 1 + 4 sources: 2-bit source, and 4 32-bit sources
* 1 destination: 32-bit destination.
```
IOP[0x02] <I32 I32> <I32@0x0> <I2@0x10 I32@0x20 I32@0x30 I32@0x40 I32@0x50>
```
